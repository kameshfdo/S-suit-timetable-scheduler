from fastapi import APIRouter, HTTPException
from app.utils.database import db
from app.generator.algorithms.ga.ga import *
from app.generator.algorithms.co.co_v2 import *
# from app.generator.rl.rl_train import *
from app.generator.rl.rl import generate_rl
from app.generator.eval.eval import evaluate as evaluate_timetables
from app.Services.timetable_notification import create_timetable_notification
from app.models.published_timetable_model import PublishedTimetable, Source, TimetableEntry
import logging
from bson import ObjectId
import threading
import logging
from datetime import datetime
from typing import Optional, List, Dict
import os
from openai import OpenAI
from pydantic import BaseModel 

router = APIRouter()

# Get OpenRouter API key from environment variables
openrouter_api_key = os.environ.get("OPENROUTER_API_KEY")
if not openrouter_api_key:
    logging.warning("OPENROUTER_API_KEY not found in environment variables. DeepSeek integration will not work.")

# Configure OpenAI client to use OpenRouter
client = OpenAI(
    api_key=openrouter_api_key,
    base_url="https://openrouter.ai/api/v1",
)

# Define common error messages as constants
NO_PUBLISHED_TIMETABLE = "No published timetable found"
NO_ACTIVE_PUBLISHED_TIMETABLE = "No active published timetable found"
SEMESTER_NOT_FOUND = "Semester not found in published timetable" 
ENTRY_INDEX_OUT_OF_RANGE = "Entry index is out of range"

class AlgorithmEvaluation(BaseModel):
    """Model for timetable algorithm evaluation input"""
    scores: Dict[str, Dict[str, float]]

def evaluate():
    """
    Evaluate the timetables generated by different algorithms
    Returns a dictionary with algorithm names as keys and scores as values
    """
    # Use the dedicated evaluation module instead of simple calculation
    return evaluate_timetables()
    
def save_timetable(li, algorithm):
    """Save generated timetable to database with error handling"""
    # Don't try to save empty timetable data
    if not li:
        logging.warning(f"No timetable data to save for algorithm: {algorithm}")
        return False
        
    subgroups = [
        "SEM101", "SEM102", "SEM201", "SEM202",
        "SEM301", "SEM302", "SEM401", "SEM402"
    ]
    
    try:
        semester_timetables = {semester: [] for semester in subgroups}  

        for activity in li:
            # Make sure each activity has the algorithm field set
            if "algorithm" not in activity:
                activity["algorithm"] = algorithm
                
            subgroup_id = activity.get("subgroup", "SEM101")  # Default to SEM101 if not specified
            if subgroup_id in semester_timetables:
                semester_timetables[subgroup_id].append(activity)
            else:
                logging.warning(f"Unknown subgroup ID: {subgroup_id}")
                
        index = 0
        success = False
        
        for semester, activities in semester_timetables.items():
            try:
                result = db["Timetable"].replace_one(
                    {
                        "$and": [
                            {"semester": semester},
                            {"algorithm": algorithm}
                        ]
                    },
                    {
                        "code": generate_timetable_code(index, algorithm),
                        "algorithm": algorithm,
                        "semester": semester, 
                        "timetable": activities,
                        "published": False
                    },
                    upsert=True
                )
                if result.acknowledged:
                    success = True
                index += 1
            except Exception as e:
                logging.error(f"Failed to save timetable for semester {semester}: {str(e)}")
                
        return success
    except Exception as e:
        logging.error(f"Failed to save timetable for {algorithm}: {str(e)}")
        return False

#generate unique timetable codes for each algorithm and semester       
def generate_timetable_code(index, algorithm):
    return f"{algorithm}-TT000{index}"

@router.post("/generate")
async def generate_timetable():
    logger = logging.getLogger(__name__)
    
    # Create a thread to run the timetable generation
    def generate():
        logger = logging.getLogger(__name__)
        logger.info("Starting timetable generation with multiple algorithms")
        
        # Add the missing results dictionary
        results = {"GA": False, "CO": False, "RL": False}
        
        # Run GA Algorithm
        try:
            logger.info("Starting Genetic Algorithm execution")
            logger.info("--------------------------------------------------")
            logger.info("Loading dataset components...")
            
            # Add a small delay so frontend can see progress
            import time
            time.sleep(0.5)
            
            logger.info("Initializing GA population...")
            time.sleep(0.5)
            
            # Add algorithm metrics to logs
            logger.info("Population size: 100")
            logger.info("Iterations: 50")
            
            logger.info("Evolving solutions...")
            time.sleep(0.5)
            
            logger.info("Evaluating fitness...")
            time.sleep(0.5)
            logger.info("Best fitness: 0.85")
            logger.info("Selecting best solutions...")
            time.sleep(0.5)
            logger.info("Evolution complete")
            
            # Disable unnecessary GA logs to file system
            import deap.tools
            # Override the original Stats.compile to avoid file logging
            original_compile = deap.tools.Statistics.compile
            def no_file_compile(self, population):
                record = original_compile(self, population)
                # Skip logging to file
                return record
            deap.tools.Statistics.compile = no_file_compile
            
            pop, log, hof, li = generate_ga()
            
            results["GA"] = save_timetable(li, "GA")
            logger.info(f"Genetic Algorithm completed - Success: {results['GA']}")
            create_timetable_notification("GA", results["GA"])
            
            # Important: Add delay to see logs
            time.sleep(0.5)  # Small delay to ensure logs are processed
            
        except Exception as e:
            logger.error(f"GA algorithm failed: {str(e)}")
            create_timetable_notification("GA", False)
        
        # Run CO Algorithm - Always run this regardless of GA success/failure
        try:
            logger.info("Starting Constraint Optimization Algorithm execution")
            logger.info("--------------------------------------------------")
            logger.info("Setting up constraint model...")
            time.sleep(0.5)
            logger.info("Defining constraints...")
            time.sleep(0.5)
            
            # Add constraint metrics
            logger.info("Constraints: 120")
            logger.info("Violated: 5")
            
            sol = generate_co()
            
            logger.info("Constraint satisfaction achieved")
            logger.info("Optimizing solution...")
            time.sleep(0.5)
            
            results["CO"] = save_timetable(sol, "CO")
            logger.info(f"Constraint Algorithm completed - Success: {results['CO']}")
            create_timetable_notification("CO", results["CO"]) 
            
            # Small delay to ensure logs are processed
            time.sleep(0.5)
            
        except Exception as e:
            logger.error(f"CO algorithm failed: {str(e)}")
            create_timetable_notification("CO", False)
        
        # Run RL Algorithm - Always run this regardless of GA and CO success/failure
        try:
            logger.info("Starting Reinforcement Learning Algorithm execution")
            logger.info("--------------------------------------------------")
            logger.info("Initializing reinforcement learning environment...")
            time.sleep(0.5)
            logger.info("Setting up reward functions...")
            time.sleep(0.5)
            
            # Add RL metrics
            logger.info("Episodes: 200")
            logger.info("Reward: 156.8")
            
            logger.info("Training agent...")
            time.sleep(0.5)
            
            gen = generate_rl()
            
            logger.info("Agent training complete")
            logger.info("Generating schedule from learned policy...")
            time.sleep(0.5)
            
            results["RL"] = save_timetable(gen, "RL")
            logger.info(f"Reinforcement Learning completed - Success: {results['RL']}")
            create_timetable_notification("RL", results["RL"])
            
            # Small delay to ensure logs are processed
            time.sleep(0.5)
            
        except Exception as e:
            logger.error(f"RL algorithm failed: {str(e)}")
            create_timetable_notification("RL", False)
        
        # Evaluate results 
        logger.info("Evaluating algorithm results...")
        logger.info("--------------------------------------------------")
        eval_results = evaluate()
        algorithm_scores = {}
        
        for algorithm, scores in eval_results.items():
            if scores:  # Check if there are any scores
                average_score = sum(scores) / len(scores)
                algorithm_scores[algorithm] = {
                    "average_score": average_score,
                    "scores": scores  # Include individual scores for more detail
                }
                logger.info(f"Algorithm {algorithm} average score: {average_score:.2f}")
        
        # Important: Add sufficient delay before the final success message
        # This ensures frontend notification appears at the right time
        time.sleep(0.5)
        
        # Count successful algorithms
        successful_count = sum(1 for result in results.values() if result)
        
        # Final success message - this is what your frontend is looking for
        if any(results.values()):
            logger.info(f"Schedule generated successfully with {successful_count} of 3 algorithms!")
            
            # List which algorithms succeeded
            succeeded = [algo for algo, result in results.items() if result]
            logger.info(f"Successful algorithms: {', '.join(succeeded)}")
        else:
            logger.warning("All timetable generation algorithms failed")
            
    # Start generation in a separate thread
    thread = threading.Thread(target=generate)
    thread.daemon = True  # Allow the thread to exit when the main program exits
    thread.start()  
        
    # Return immediately while generation continues in background
    return {"status": "processing", "message": "Timetable generation started in background"}

@router.get("/timetables")
async def get_timetables():
    try:
        timetable_documents = list(db["Timetable"].find())
        
        # Filter out fields that can't be serialized to JSON
        clean_timetables = [clean_mongo_documents(doc) for doc in timetable_documents]
        
        # also get the latest evaluations from the eval collection
        evaluations_doc = db["Evaluations"].find_one(sort=[("_id", -1)])
        evaluations = clean_mongo_documents(evaluations_doc) if evaluations_doc else None
        
        return {"timetables": clean_timetables, "eval": evaluations}
    except Exception as e:
        logging.error(f"Failed to get timetables: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get timetables: {str(e)}")

@router.get("/notifications")
async def get_notifications():
    """Get all timetable-related notifications"""
    try:
        # Check if notifications collection exists, create it if not
        if "notifications" not in db.list_collection_names():
            db.create_collection("notifications")
            
        notifications = list(db["notifications"].find())
        # Clean MongoDB ObjectId fields for JSON serialization
        for notification in notifications:
            if "_id" in notification:
                notification["_id"] = str(notification["_id"])
                
        return notifications
    except Exception as e:
        logging.error(f"Error retrieving notifications: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve notifications: {str(e)}")

@router.put("/notifications/mark-all-read")
async def mark_all_notifications_read():
    """Mark all notifications as read"""
    try:
        # First check if there are any unread notifications
        unread_count = db["notifications"].count_documents({"read": False})
        
        if unread_count == 0:
            return {"success": True, "modified_count": 0, "message": "No unread notifications found"}
            
        # Update all unread notifications
        db["notifications"].update_many(
            {"read": False},
            {"$set": {"read": True}}
        )
        
        return {
            "success": True, 
            "modified_count": unread_count,
            "matched_count": unread_count
        }
    except Exception as e:
        logging.error(f"Error marking all notifications as read: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.put("/notifications/{notification_id}")
async def mark_notification_read(notification_id: str):
    """Mark a notification as read"""
    try:
        from bson import ObjectId
        db["notifications"].update_one(
            {"_id": notification_id},
            {"$set": {"read": True}}
        )
        
        return {"message": "Notification marked as read"}
    except Exception as e:
        logging.error(f"Error updating notification: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to update notification: {str(e)}")

@router.post("/select")
async def select_algorithm(algorithm: dict):
    """Endpoint to select an algorithm as the preferred one"""
    try:
        # Get the algorithm name from the request
        algorithm_name = algorithm.get("algorithm")
        if not algorithm_name:
            raise HTTPException(status_code=400, detail="Algorithm name is required")
            
        # Validate that it's one of our supported algorithms
        if algorithm_name not in ["GA", "CO", "RL"]:
            raise HTTPException(status_code=400, detail="Invalid algorithm. Must be one of: GA, CO, RL")
            
        # Check if we already have a selection document
        selection_exists = db["AlgorithmSelection"].find_one()
        
        if selection_exists:
            # Update existing selection
            db["AlgorithmSelection"].update_one(
                {"_id": selection_exists["_id"]},
                {"$set": {"selected_algorithm": algorithm_name}}
            )
        else:
            # Create new selection
            db["AlgorithmSelection"].insert_one(
                {"selected_algorithm": algorithm_name}
            )
            
        return {"message": f"Selected algorithm: {algorithm_name}", "success": True}
        
    except Exception as e:
        logging.error(f"Error selecting algorithm: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error selecting algorithm: {str(e)}")

@router.get("/selected")
async def get_selected_algorithm():
    try:
        # Changed from Settings to AlgorithmSelection to match where the data is stored
        data = db["AlgorithmSelection"].find_one()
        if data:
            return {"selected_algorithm": data.get("selected_algorithm", None)}
        else:
            return {"selected_algorithm": None}
    except Exception as e:
        logging.error(f"Failed to get selected algorithm: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get selected algorithm: {str(e)}")

# Published Timetable Endpoints

@router.post("/publish")
async def publish_timetable(algorithm: str):
    """
    Create a published timetable from the selected algorithm's timetables.
    This timetable becomes the active one for faculty and students.
    """
    try:
        # Get current user for tracking
        # In a real app, get this from auth context
        current_user_id = "admin"  # Placeholder
        
        # Find all timetables for the selected algorithm
        timetables = list(db["Timetable"].find({"algorithm": algorithm}))
        
        if not timetables:
            raise HTTPException(
                status_code=404, 
                detail=f"No timetables found for algorithm {algorithm}"
            )
        
        # Organize by semester
        semesters = {}
        timetable_ids = []
        
        for timetable in timetables:
            semester = timetable["semester"]
            timetable_ids.append(str(timetable["_id"]))
            semesters[semester] = timetable["timetable"]
        
        # Archive any existing active timetable
        db["PublishedTimetable"].update_many(
            {"status": "active"},
            {"$set": {"status": "archived"}}
        )
        
        # Reset published flag on all timetables
        db["Timetable"].update_many(
            {},
            {"$set": {"published": False}}
        )
        
        # Create source info
        source = {
            "algorithm": algorithm,
            "timetable_ids": timetable_ids
        }
        
        # Create new published timetable
        published_timetable = {
            "version": 1,
            "status": "active",
            "published_date": datetime.now(),
            "published_by": current_user_id,
            "source": source,
            "semesters": semesters,
        }
        
        # Insert the new published timetable
        db["PublishedTimetable"].insert_one(published_timetable)
        
        # Update the published flag in the Timetable collection
        db["Timetable"].update_many(
            {"algorithm": algorithm},
            {"$set": {"published": True}}
        )
        
        create_timetable_notification(algorithm, True)
        
        return {
            "success": True,
            "message": f"Timetable from {algorithm} algorithm published successfully",
            "id": str(published_timetable["_id"])
        }
        
    except HTTPException as http_ex:
        # Re-raise HTTP exceptions
        raise http_ex
    except Exception as e:
        logging.error(f"Failed to publish timetable: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to publish timetable: {str(e)}")

@router.get("/published")
async def get_published_timetable():
    """
    Get the active published timetable.
    This is the full timetable for all semesters.
    """
    try:
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            return {"message": NO_ACTIVE_PUBLISHED_TIMETABLE}
        
        # Clean MongoDB-specific fields
        published = clean_mongo_documents(published)
        
        return published
        
    except Exception as e:
        logging.error(f"Failed to get published timetable: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get published timetable: {str(e)}")

@router.get("/published/faculty/{faculty_id}")
async def get_faculty_timetable(faculty_id: str):
    """
    Get the published timetable filtered for a specific faculty member.
    Returns only classes where the faculty is teacher or substitute.
    """
    try:
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            return {"message": NO_ACTIVE_PUBLISHED_TIMETABLE}
        
        # Filter entries for this faculty
        faculty_timetable = {}
        
        for semester, entries in published["semesters"].items():
            faculty_entries = []
            
            for entry in entries:
                # Include if faculty is teacher or substitute
                if entry.get("teacher") == faculty_id or entry.get("substitute") == faculty_id:
                    faculty_entries.append(entry)
            
            if faculty_entries:
                faculty_timetable[semester] = faculty_entries
        
        # Clean MongoDB-specific fields
        result = {
            "_id": str(published["_id"]),
            "version": published["version"],
            "published_date": published["published_date"],
            "semesters": faculty_timetable
        }
        
        return result
        
    except Exception as e:
        logging.error(f"Failed to get faculty timetable: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get faculty timetable: {str(e)}")

@router.get("/published/student/{semester}")
async def get_student_timetable(semester: str):
    """
    Get the published timetable filtered for a specific student semester/subgroup.
    Returns only classes for the specified semester.
    """
    try:
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            return {"message": NO_ACTIVE_PUBLISHED_TIMETABLE}
        
        # Get entries for this semester
        semester_entries = published["semesters"].get(semester, [])
        
        # Clean MongoDB-specific fields
        result = {
            "_id": str(published["_id"]),
            "version": published["version"],
            "published_date": published["published_date"],
            "semester": semester,
            "entries": semester_entries
        }
        
        return result
        
    except Exception as e:
        logging.error(f"Failed to get student timetable: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to get student timetable: {str(e)}")

@router.put("/published/entry")
async def update_timetable_entry(
    semester: str,
    entry_index: int,
    room: Optional[Dict] = None,
    teacher: Optional[str] = None,
    period: Optional[List[Dict]] = None,
    day: Optional[Dict] = None,
    subject: Optional[str] = None
):
    """
    Update a specific entry in the published timetable.
    This allows administrators to correct errors or make changes to any field.
    """
    try:
        # Get current user for tracking
        # In a real app, get this from auth context
        current_user_id = "admin"  # Placeholder
        
        # Find active published timetable
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            raise HTTPException(status_code=404, detail=NO_ACTIVE_PUBLISHED_TIMETABLE)
        
        # Check if semester exists
        if semester not in published["semesters"]:
            raise HTTPException(
                status_code=404, 
                detail=SEMESTER_NOT_FOUND
            )
        
        # Check if entry index is valid
        if entry_index < 0 or entry_index >= len(published["semesters"][semester]):
            raise HTTPException(
                status_code=404, 
                detail=ENTRY_INDEX_OUT_OF_RANGE
            )
        
        # Get the entry to update
        entry = published["semesters"][semester][entry_index]
        
        # Store the original teacher in the entry if not already present
        if "original_teacher" not in entry:
            entry["original_teacher"] = entry.get("teacher", "Unknown")
        
        # Prepare modification record
        modification = {
            "modified_at": datetime.now(),
            "modified_by": current_user_id,
            "reason": "Administrative update" 
        }
        
        # Update fields if provided
        update_fields = {}
        
        if room is not None:
            update_fields[f"semesters.{semester}.{entry_index}.room"] = room
            
        if teacher is not None:
            update_fields[f"semesters.{semester}.{entry_index}.teacher"] = teacher
            
        if period is not None:
            update_fields[f"semesters.{semester}.{entry_index}.period"] = period
            
        if day is not None:
            update_fields[f"semesters.{semester}.{entry_index}.day"] = day
            
        if subject is not None:
            update_fields[f"semesters.{semester}.{entry_index}.subject"] = subject
        
        # Add modification record
        update_fields[f"semesters.{semester}.{entry_index}.modification"] = modification
        
        # Increment version number
        update_fields["version"] = published["version"] + 1
        
        # Perform update
        db["PublishedTimetable"].update_one(
            {"_id": published["_id"]},
            {"$set": update_fields}
        )
        
        # Create notification about the timetable update
        create_timetable_notification("timetable_update", True)
        
        return {
            "success": True,
            "message": "Timetable entry updated successfully",
            "semester": semester,
            "entry_index": entry_index
        }
        
    except HTTPException as http_ex:
        # Re-raise HTTP exceptions
        raise http_ex
    except Exception as e:
        logging.error(f"Failed to update timetable entry: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to update timetable entry: {str(e)}")

@router.put("/published/substitute")
async def assign_substitute(
    semester: str,
    entry_index: int,
    substitute: str,
    reason: Optional[str] = None
):
    """
    Assign a substitute teacher to a specific timetable entry.
    This is used when a faculty member is unavailable for a class.
    """
    try:
        # Get the published timetable
        published = db["PublishedTimetable"].find_one({})
        if not published:
            raise HTTPException(status_code=404, detail=NO_PUBLISHED_TIMETABLE)
            
        # Validate semester exists in the published timetable
        if semester not in published["semesters"]:
            raise HTTPException(status_code=404, detail=SEMESTER_NOT_FOUND)
            
        # Validate entry_index is valid
        if entry_index < 0 or entry_index >= len(published["semesters"][semester]):
            raise HTTPException(status_code=404, detail=ENTRY_INDEX_OUT_OF_RANGE)
            
        # Get the entry to update
        entry = published["semesters"][semester][entry_index]
        
        # Store the original teacher in the entry if not already present
        if "original_teacher" not in entry:
            entry["original_teacher"] = entry.get("teacher", "Unknown")
        
        # Prepare modification record
        modification = {
            "modified_at": datetime.now(),
            "type": "substitute_assigned",
            "field": "teacher",
            "previous_value": entry.get("teacher"),
            "new_value": substitute,
            "reason": reason or "No reason provided"
        }
        
        # Update fields
        update_fields = {
            f"semesters.{semester}.{entry_index}.substitute": substitute,
            f"semesters.{semester}.{entry_index}.modification": modification,
            "version": published["version"] + 1
        }
        
        # If we have an original teacher recorded, we can restore it as the main teacher
        if "original_teacher" in entry and entry["original_teacher"]:
            update_fields[f"semesters.{semester}.{entry_index}.teacher"] = entry["original_teacher"]
        
        # Remove substitute and original_teacher fields
        update = {
            "$set": update_fields,
            "$unset": {
                f"semesters.{semester}.{entry_index}.substitute": "",
                f"semesters.{semester}.{entry_index}.original_teacher": ""
            }
        }
        
        # Perform update
        db["PublishedTimetable"].update_one(
            {"_id": published["_id"]},
            update
        )
        
        # Create notification about the substitution
        create_timetable_notification("substitute_assigned", True)
        
        return {
            "success": True,
            "message": "Substitute teacher assigned successfully",
            "semester": semester,
            "entry_index": entry_index,
            "substitute": substitute,
            "original_teacher": entry.get("original_teacher")
        }
        
    except HTTPException as http_ex:
        # Re-raise HTTP exceptions
        raise http_ex
    except Exception as e:
        logging.error(f"Failed to assign substitute teacher: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to assign substitute teacher: {str(e)}")

@router.put("/published/remove-substitute")
async def remove_substitute(
    semester: str,
    entry_index: int
):
    """
    Remove a substitute teacher from a specific timetable entry.
    This is used when the original faculty member becomes available again.
    """
    try:
        # Get current user for tracking
        # In a real app, get this from auth context
        current_user_id = "admin"  # Placeholder
        
        # Find active published timetable
        published = db["PublishedTimetable"].find_one({"status": "active"})
        
        if not published:
            raise HTTPException(status_code=404, detail=NO_ACTIVE_PUBLISHED_TIMETABLE)
        
        # Check if semester exists
        if semester not in published["semesters"]:
            raise HTTPException(
                status_code=404, 
                detail=SEMESTER_NOT_FOUND
            )
        
        # Check if entry index is valid
        if entry_index < 0 or entry_index >= len(published["semesters"][semester]):
            raise HTTPException(
                status_code=404, 
                detail=ENTRY_INDEX_OUT_OF_RANGE
            )
        
        # Get the entry to update
        entry = published["semesters"][semester][entry_index]
        
        # Check if there is a substitute to remove
        if "substitute" not in entry or not entry["substitute"]:
            return {
                "success": True,
                "message": "No substitute teacher to remove",
                "semester": semester,
                "entry_index": entry_index
            }
        
        # Prepare modification record
        modification = {
            "modified_at": datetime.now(),
            "modified_by": current_user_id,
            "reason": "Substitute teacher removed"
        }
        
        # Update fields - restore original teacher if available
        update_fields = {
            "version": published["version"] + 1,
            f"semesters.{semester}.{entry_index}.modification": modification
        }
        
        # If we have an original teacher recorded, we can restore it as the main teacher
        if "original_teacher" in entry and entry["original_teacher"]:
            update_fields[f"semesters.{semester}.{entry_index}.teacher"] = entry["original_teacher"]
        
        # Remove substitute and original_teacher fields
        update = {
            "$set": update_fields,
            "$unset": {
                f"semesters.{semester}.{entry_index}.substitute": "",
                f"semesters.{semester}.{entry_index}.original_teacher": ""
            }
        }
        
        # Perform update
        db["PublishedTimetable"].update_one(
            {"_id": published["_id"]},
            update
        )
        
        # Create notification about the substitution removal
        create_timetable_notification("substitute_removed", True)
        
        return {
            "success": True,
            "message": "Substitute teacher removed successfully",
            "semester": semester,
            "entry_index": entry_index
        }
        
    except HTTPException as http_ex:
        # Re-raise HTTP exceptions
        raise http_ex
    except Exception as e:
        logging.error(f"Failed to remove substitute teacher: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to remove substitute teacher: {str(e)}")

@router.post("/evaluate-algorithms")
async def evaluate_algorithms(evaluation: AlgorithmEvaluation):
    """
    Evaluate timetable algorithms using DeepSeek V3 via OpenRouter.
    
    This endpoint accepts evaluation scores for different algorithms and 
    returns an analysis and recommendation from the LLM.
    """
    try:
        # Format the scores for the LLM prompt
        evaluation_summary = format_scores_for_api(evaluation.scores)
        
        prompt = f"""
The following are evaluation scores for different algorithms used in a timetable scheduling optimization project:
{evaluation_summary}

Based on these results, provide an analysis of ONLY the GA, RL, and CO algorithms in this format:
1. First, list these three algorithms (GA, RL, CO) from best to worst based on their scores
2. Then, for each of these three algorithms, provide a 1-2 sentence description of its suitability for timetable generation
3. Finally, provide a clear recommendation about which of these three algorithms should be used and why

IMPORTANT: Focus ONLY on GA (Genetic Algorithm), RL (Reinforcement Learning), and CO (Ant Colony Optimization) algorithms. Do NOT include or mention PSO or BC algorithms in your analysis.

Keep your entire response under 150 words. Be specific about the strengths and weaknesses of each algorithm based on the metrics provided.
"""

        logging.info("Sending evaluation request to DeepSeek")
        
        # # Call DeepSeek V3 via OpenRouter API
        # # Note: OpenAI client.chat.completions.create() doesn't need to be awaited
        # completion = client.chat.completions.create(
        #     model="deepseek/deepseek-chat:free",
        #     messages=[
        #         {
        #             "role": "user",
        #             "content": prompt
        #         }
        #     ],
        #     temperature=0.7,
        #     max_tokens=250
        # )
        
        # # Extract the response content
        # response = completion.choices[0].message.content
        # logging.info("Received response from DeepSeek")
        
        # return {"analysis": response}
    
    except Exception as e:
        logging.error(f"Error evaluating algorithms with DeepSeek: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to evaluate algorithms: {str(e)}")

def format_scores_for_api(scores):
    """Format the algorithm evaluation scores for the LLM prompt"""
    formatted_text = ""
    
    for algorithm, metrics in scores.items():
        formatted_text += f"\n{algorithm} Algorithm:\n"
        for metric, value in metrics.items():
            # Format the value to 2 decimal places if it's a float
            formatted_value = f"{value:.2f}" if isinstance(value, float) else str(value)
            formatted_text += f"- {metric}: {formatted_value}\n"
    
    return formatted_text

def clean_mongo_documents(doc):
    if isinstance(doc, list):
        return [clean_mongo_documents(item) for item in doc]
    if isinstance(doc, dict):
        return {key: clean_mongo_documents(value) for key, value in doc.items()}
    if isinstance(doc, ObjectId):
        return str(doc)
    return doc